#lang racket
"1"
(*(+ 11 22) (- 44 33))
(+ 4 8 15 16 23 42)
(+(/(- 3 2) 4) (* 5 (- 6 7)))
(+ (* 3 (- 4 (expt 2 15))) 6)
(define (x-256 x)
  (let* ((x4 (* x x x x))
        (x16 (* x4 x4 x4 x4))
        (x64 (* x16 x16 x16 x16))
        (x256 (* x64 x64 x64 x64))) 
    x256));body
(x-256 2)

"2"
(- 15 5)
(+ (/ 1 2) (/ 1 3))
(* 18 8 10)
(- (+ 10 4) (* 4 1))
(* (+ 2 2) (/ (* (+ 3 5) (/ 30 10)) 2))
"3"
(define (area-of-triangle b h)
  (* (* .5 b) h))
(area-of-triangle 55 32)

(define (cash-money p n d q)
  (let ((p (* p .01))
       (n (* n .05))
       (d (* d .10))
       (q (* q .25)))
  (+ p n d q)))
(cash-money 3 0 0 2)

(define (sigmoid x)
  (/ x (sqrt(+ 1 (expt x 2)))))
(sigmoid 5)
(require plot)
(plot (line sigmoid)
      #:x-min -5 #:x-max 5 #:y-min -5 #:y-max 5) 

(define (think-positive x)
  (if (> x 0)
      x
      0))
(think-positive 3)
(think-positive -1)

"4"
(define (repeat i)
  (if (= i 0)
      0
      (+ (repeat (- i 1.0)) (/ 1 (expt 10.0 i)))))
(repeat 3)
(repeat 9)
"b"
(define (repeater i)
(define (even n) (= (modulo n 2) 0))
    (cond ((= i 1) 0.0)
          ((even i) (+ (/ 4.0 (expt 10 i)) (repeater (- i 1))))
          (else     (+ (/ 5.0 (expt 10 i)) (repeater (- i 1))))))
(repeater 9)
"c"
(define (sum-of-squares n)
  (define (sum-help m n)
    (cond ((< n 0) #f)
          ((m n) #t)
          (else (sum-help m (- n 1)))))
  (sum-help (lambda (ok)
            (sum-help (lambda (orite)
                        (if (= (+ (* ok ok) (* orite orite)) n)
                            #t 
                            #f))
                      (floor (sqrt n))))
            (floor (sqrt n))))
 (sum-of-squares 3)
 (sum-of-squares 5)
 (sum-of-squares 8)
 (sum-of-squares 10)
 (sum-of-squares 11)
 (sum-of-squares 12)
 (sum-of-squares 99)
 
 "5"
 (define (prod f n)
     (if (= n 0)
         (f n)
         (* (f n) (prod f (- n 1)))))
   (define (fact n)
     (prod (lambda (x) (if (= x 0) 1 x)) n))
   
   ;; double fact (version 1 ~ replace even terms with 1)
   (define (dfact n)
     (prod (lambda (x) (if (= (modulo x 2) 1) x 1)) n))
   ;; double fact (version 2 ~ follow handout and remap)
   (define (dfact2 n)
     (prod (lambda (x) (if (= x 0) 1 (- (* 2 x) 1))) (/ (+ n 1) 2)))

   (define (even x)  (= (modulo x 2) 0))
(define (twice x) (* x 2))
(define (half x)  (/ x 2))  
   
(define (rfmult a b)
    (cond ((= 0 a) 0)
          ((= 0 b) 0)
((even a) (twice (rfmult (half a) b)))
(else     (+ b (twice (rfmult (half (- a 1))
b)))
)))
   (rfmult 30 6)

   (let ((x 10))
  (define (g y) (+ x y))
  (let ((x 100))
    (g 1000)))

(define (fact-cps n)
       (define (fact-c m c)
         (if (= m 0) (c 1)
             (fact-c (- m 1)
                     (lambda (x) (c (* m x))))))
       (fact-c n (lambda (x) x)))
(fact-cps 5)

"5again"
(define (sum f n)
  (if (= n 0)
      (f 0)
      (+ (f n) (sum f (- n 1)))))
(define (product f n)
  (if (= n 0)
      (f n)
      (* (f n) (product f (- n 1)))))
(define (fact-a n)
  (product (lambda (x) (if (= x 0) 1 x)) n))
 (fact-a 5)
(fact 5)

(define (f-comp f g)
  (lambda (x) 
    (f (g x))))
((f-comp (lambda (x) (- (* 5 x) 4)) (lambda (x) (+ (expt x 2) 3))) 1)

(define (delta f)
  (lambda (x) (- (f (+ x 1)) (f x))))
(let* ((f (lambda (x) (+ (* 16 x) 4)))
       (df (delta f)))
  (begin
    (display (df 1))
    (newline)
    (display (df 3))
    (newline)
    (display (df 4))
    (newline)))
(let* ((f (lambda (x) (+ (* 11 x x) (* -4 x) 11)))
       (ddf (delta (delta f))))
  (begin
    (display (ddf 1))
    (newline)
    (display (ddf 3))
    (newline)
    (display (ddf 4))
    (newline)))
             