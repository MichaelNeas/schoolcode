#lang racket
"1"
(define (number-object)
  (let ((current 0))
    (define (inc)
      (begin (set! current (+ current 1))
             current))
    (define (decrease)
      (begin (set! current (- current 1))
             current))
    (define (10xmult)
      (begin (set! current (* current 10))
             current))
    (define (10xdec) 
      (begin (if (not (= (remainder current 10) 0))
             (begin (set! current (- current (remainder current 10))) 
                    (set! current (/ current 10)))
             (/ current 10))
             current))
    (define (ones)
      (remainder current 10)) ;remainder divides the first value by the second and gives the value of the remainder
    (define (zero?)
      (if (= current 0)
          #t
          #f))
    (define (pos?)
      (if (< 0 current)
          #t
          #f))
    (lambda (method)
      (cond ((eq? method 'increment) inc)
            ((eq? method 'decrement) decrease)
            ((eq? method 'power-up) 10xmult)
            ((eq? method 'power-down) 10xdec)
            ((eq? method 'ones-digit) ones)
            ((eq? method 'zero?) zero?)
            ((eq? method 'positive?) pos?)
            ((eq? method 'current-total) current)))))

(define my-object (number-object))
((my-object 'increment))
((my-object 'increment))
((my-object 'increment))
((my-object 'increment))
((my-object 'increment))
((my-object 'increment))
((my-object 'decrement))
((my-object 'power-up))
((my-object 'increment))
((my-object 'increment))
((my-object 'increment))
((my-object 'increment))
((my-object 'power-up))
((my-object 'increment))
((my-object 'increment))
((my-object 'zero?))
((my-object 'positive?))
((my-object 'power-up))
((my-object 'increment))
((my-object 'increment))
((my-object 'increment))
((my-object 'power-up))
((my-object 'increment))
((my-object 'ones-digit))
(my-object 'current-total)
((my-object 'power-down))
((my-object 'power-down))
((my-object 'power-down))

"2"
(define (first str) (car str))
(define (rest str) ((cdr str)))

(define (merge s t)
  (if (>= (first s) (first t))
      (cons (first t) (lambda () (merge s (rest t))))
      (cons (first s) (lambda () (merge (rest s) t)))))

(define (cube-square-stream s)
  (cons (expt (expt s 3) 2) (lambda () (cube-square-stream (+ s 1)))))
(define (square-cube-stream t)
  (cons (expt (expt t 2) 3) (lambda () (square-cube-stream (+ t 1)))))
(define (perfect-squares s)
  (cons (expt s 2) (lambda () (perfect-squares (+ s 1)))))
(define (perfect-cubes s)
  (cons (expt s 3) (lambda () (perfect-cubes (+ s 1)))))

(define test-cube (perfect-cubes 2))
test-cube
(rest test-cube)
(rest (rest test-cube))
(rest (rest (rest test-cube)))

(define example-stream (merge (perfect-squares 1) (perfect-cubes 1)))
example-stream
(rest example-stream)
(rest (rest example-stream))
(rest (rest (rest example-stream)))
(rest (rest (rest (rest example-stream))))
(rest (rest (rest (rest (rest example-stream)))))

(define duplicate-stream (merge (cube-square-stream 1) (square-cube-stream 1)))
duplicate-stream
(rest duplicate-stream)
(rest (rest duplicate-stream))
(rest (rest (rest duplicate-stream))) ;64's are twice output so good
(rest (rest (rest (rest duplicate-stream))))

"3"
(define (2x-stream s)
  (cons (* 2 s) (lambda () (2x-stream (+ s 1)))))
(define (3x-stream s)
  (cons (* 3 s) (lambda () (3x-stream (+ s 1)))))
(define (5x-stream s)
  (cons (* 5 s) (lambda () (5x-stream (+ s 1)))))
(define (dividable? a b) (= (modulo b a) 0))


(define (new-merge a b c)
        (cond ((and (<= (first a) (first b)) (<= (first a) (first c)))
               (cons (first a) (lambda () (new-merge (rest a) b c))))
              ((and (<= (first b) (first a)) 
                    (<= (first b) (first c)) 
                    (not (dividable? 2 (first b))))
               (cons (first b) (lambda () (new-merge a (rest b) c))))
              ((dividable? 2 (first b)) (new-merge a (rest b) c))
              ((and (<= (first c) (first a)) 
                    (<= (first c) (first b)) 
                    (and (not (dividable? 2 (first c)))
                         (not (dividable? 3 (first c)))))
               (cons (first c) (lambda () (new-merge a b (rest c)))))
              (else (new-merge a b (rest c)))))
              


(define divmerge (new-merge (2x-stream 1) (3x-stream 1) (5x-stream 1)))
divmerge
(rest divmerge)
(rest (rest divmerge))
(rest (rest (rest divmerge)))
(rest (rest (rest (rest divmerge)))) 
(rest (rest (rest (rest (rest divmerge)))))
(rest (rest (rest (rest (rest (rest divmerge))))))
(rest (rest (rest (rest (rest (rest (rest divmerge)))))))
(rest (rest (rest (rest (rest (rest (rest (rest divmerge))))))))
(rest (rest (rest (rest (rest (rest (rest (rest (rest divmerge)))))))))
(rest (rest (rest (rest (rest (rest (rest (rest (rest (rest divmerge))))))))))
(rest (rest (rest (rest (rest (rest (rest (rest (rest (rest (rest divmerge)))))))))))
(rest (rest (rest (rest (rest (rest (rest (rest (rest (rest (rest (rest divmerge))))))))))))
(rest (rest (rest (rest (rest (rest (rest (rest (rest (rest (rest (rest (rest divmerge)))))))))))))
;code works perfectly! sorry for all the tests!!
"4"
(define (stream-zip s1 s2)
  (cons (cons (first s1) (first s2)) (lambda () (stream-zip (rest s1)  (rest s2)))))
(define zippy (stream-zip (perfect-squares 1) (perfect-cubes 1)))
zippy
(rest zippy)
(rest (rest zippy))
(rest (rest (rest zippy)))
(rest (rest (rest (rest zippy))))
"5"
(require racket/draw)
(define (head s) (car s))
(define (delay something) (lambda () something))
"a"
(define (make-complex a b) (cons a b))
(define (c-add c1 c2)
  (make-complex (+ (car c1) (car c2)) (+ (cdr c1) (cdr c2))))
(define (c-multiply c1 c2)
  (make-complex (- (* (car c1) (car c2))
                   (* (cdr c1) (cdr c2)))
                (+ (* (car c1) (cdr c2))
                   (* (cdr c1) (car c2)))))
(define (length-c c)
  (sqrt (+ (* (car c) (car c))
           (* (cdr c) (cdr c)))))
"b"
(define (mandelbrot z a)
  (cons a (lambda () (mandelbrot z (c-add (c-multiply a a) z)))))
(define mtest (mandelbrot (cons (/ 1 2) (/ 1 2)) '(0 . 0)))
mtest
(rest mtest)
(rest (rest mtest))
(rest (rest (rest mtest)))
(rest (rest (rest (rest mtest))))
(rest (rest (rest (rest (rest mtest)))))

(define (mandelbrotz z)
  (mandelbrot z (cons 0 0)))

"c"                                         
(define (s-map f s)
  (if (null? s)
      '()
      (cons (f (car s))
            (lambda () (s-map f (rest s))))))

(define (mandelbrot-l z)
  (s-map length-c (mandelbrotz z)))
(define mandtest (mandelbrot-l '(1/2 . 1/2)))
mandtest
(rest mandtest)
(rest (rest mandtest))
(rest (rest (rest mandtest)))
(rest (rest (rest (rest mandtest))))

"d"
(define (depth z max)
  (define (depth-help ml index)
    (cond ((< 2 (head ml)) index)
          ((= max index) max)
          (else (depth-help (rest ml) (+ 1 index)))))
  (depth-help (mandelbrot-l z) 0))
        
(depth '(1/2 . 1/2) 10)


(define (iter->color i) 
  (if (= i 255)
      (make-object color% "black") 
      (make-object color% (* 5 (modulo i 15))
        (* 32 (modulo i 7))
        (* 8 (modulo i 31)))))

(define (mandelbroti width height)
  (define target (make-bitmap width height)) 
  (define dc (new bitmap-dc% [bitmap target])) 
  (for* ([x width] [y height])
    (define real-x (- (* 3.0 (/ x width)) 2.25))
    (define real-y (- (* 2.5 (/ y height)) 1.25))
    (send dc set-pen (iter->color (depth (cons real-x real-y)
                                         255))
          1 'solid)
    (send dc draw-point x y))
  (send target save-file "mandelbrot.png" 'png))
;(mandelbroti 900 600)
;commented out so theres no drawing


